---
layout:     post
title:      "浅析iOS10通知的应用"
subtitle:   ""
date:       2017-06-14 14:23:00
author:     "易博"
header-img: "img/201705/18/head_bg.JPG"
tags:
    - iOS
---

iOS10发布的同时苹果推出新的通知框架UserNotification，较之前的消息推送，新的框架有了质的变化。之前提到通知，理解的都是消息推送，新的通知框架在完善消息推送功能的基础上，加入了很多新的功能和权限。本文主要浅析两者的对比和实际应用

#### 新功能概览

1、不再区分本地通知和远程通知，有了统一的行为。远程通知主要是消息推送、本地通知分为以下3种

    1. UNTimeIntervalNotificationTrigger 一定时间之后，重复或者不重复推送通知
    2. UNCalendarNotificationTrigger 一定日期之后，重复或者不重复推送通知
    3. UNLocationNotificationTrigger）地理位置的一种通知，当用户进入或离开一个地理区域来通知

2、应用在前台的时候也能弹出提示。这样就不需要像之前一样自己去做处理来提醒用户

3、能够获取到用户的通知设置信息，甚至修改这些设置。以前的通知是获取不到用户对应用通知相关的设置信息

```
UNUserNotificationCenter *center = [UNUserNotificationCenter currentNotificationCenter];  
[center getNotificationSettingsWithCompletionHandler:^(UNNotificationSettings * _Nonnull settings) {  
NSLog(@"通知配置信息:\n%@",settings);  
}];
```

4、通知的发送采用类似网络请求的方式，开发者更加容易接受

5、通知的内容显示增加标题和副标题的区分，主标题加粗显示。通知类型也新增了多媒体通知，能都显示图片、音乐和视频资源

```
{  
    "aps":{  
        "alert":{  
        "title":"标题",  
        "subtitle":"副标题",  
        "body":"内容"  
        },  
    "sound":"default",  
    "badge":1  
    }  
} 
```

6、开发者可以自定义通知的UI界面，不再是一成不变的banner

7、支持本地通知的撤回、修改和删除，不论通知是否已经展示还是未到达。目前还不支持远程推送的上述操作

#### 设备注册和获取注册信息

xcode8以上，需要在工程的Capabilities中开启远程通知，并且添加UserNotifications.framework库

![](http://www.xttxqjfg.cn/img/201706/14/14001.png)

```
//注册
#import <UserNotifications/UserNotifications.h>
-(void)authorizationPushNotificaton:(UIApplication *)application  
{  
    UNUserNotificationCenter *center = [UNUserNotificationCenter currentNotificationCenter];  
    center.delegate = self; //必须写代理  
    [center requestAuthorizationWithOptions:UNAuthorizationOptionBadge | UNAuthorizationOptionSound | UNAuthorizationOptionAlert | UNAuthorizationOptionCarPlay completionHandler:^(BOOL granted, NSError * _Nullable error) {  
    //注册之后的回调  
    if (!error && granted) {  
        NSLog(@"注册成功...");  
    }  
    else{  
        NSLog(@"注册失败...");  
    }  
    }];  

    //获取注册之后的权限设置  
    //注意UNNotificationSettings是只读对象哦，不能直接修改！  
    [center getNotificationSettingsWithCompletionHandler:^(UNNotificationSettings * _Nonnull settings) {  
        NSLog(@"通知配置信息:\n%@",settings);  
    }];  

    //注册通知获取token  
    [application registerForRemoteNotifications];  
}
```

```
//在App启动之后调用上述方法注册
- (BOOL)application:(UIApplication *)application didFinishLaunchingWithOptions:(NSDictionary *)launchOptions {  
    // Override point for customization after application launch.   

    [UNUserNotificationCenter currentNotificationCenter].delegate = [NotificationHandle shareInstance];  

    [[NotificationHandle shareInstance] authorizationPushNotificaton:application];  

    return YES;  
} 

//注册成功的处理
-(void)application:(UIApplication *)application didRegisterForRemoteNotificationsWithDeviceToken:(NSData *)deviceToken{  

    NSString *deviceString = [[deviceToken description] stringByTrimmingCharactersInSet:[NSCharacterSet characterSetWithCharactersInString:@"<>"]];  
    deviceString = [deviceString stringByReplacingOccurrencesOfString:@" " withString:@""];  

    NSLog(@"远端获取的deviceToken\n%@",deviceString);  

    //存储得到的token，后面备用  
    [[NSUserDefaults standardUserDefaults] setValue:deviceString forKey:@"deviceToken"];  
    [[NSUserDefaults standardUserDefaults] synchronize];  
}  

//注册失败的处理
-(void)application:(UIApplication *)application didFailToRegisterForRemoteNotificationsWithError:(NSError *)error{  
    NSLog(@"获取token失败:%@\n",error.localizedDescription);  
}
```

#### 发送通知

之前已经提到过，通知发送采用的是类似网络请求的代码风格。我们创建一个通知请求(request)，然后将这个请求提交给UNUserNotificationCenter处理，之后会在代理(delegate)中收到这个通知请求对应的回应(response)，另外，我们也可以在应用的拓展中对回应进行处理。下面是发送一个简单通知的示例代码段、远程推送的info信息和效果图

```
//创建通知  
UNMutableNotificationContent *content = [[UNMutableNotificationContent alloc]init];  
content.title = @"iOS 10通知";  
content.body = @"这是一个iOS 10的消息通知...";  

//创建一个触发事件  
UNNotificationTrigger *trigger = [UNTimeIntervalNotificationTrigger triggerWithTimeInterval:timeValue repeats:NO];  

//设置通知的唯一标识  
NSString *requestIdentifer = @"timeIntervalNotification";  

//创建通知的请求  
UNNotificationRequest *request = [UNNotificationRequest requestWithIdentifier:requestIdentifer content:content trigger:trigger];  
    [[UNUserNotificationCenter currentNotificationCenter] addNotificationRequest:request withCompletionHandler:^(NSError * _Nullable error) {  
    if (!error) {  
        self.label2.text = error.localizedDescription;  
    }  
    else  
    {  
        self.label2.text = @"发送成功...";  
    }  
}];

{  
    "aps":{  
        "alert":{  
        "title":"iOS 10通知",  
        "body":"这是一个iOS 10的消息通知..."  
        }  
    }  
}
```

![](http://www.xttxqjfg.cn/img/201706/14/14002.png)

#### 通知的取消和修改

在上述代码段中，我们在发送一个通知请求的时候会有一个标识符，这个标识符就是用来管理通知。利用UserNotifications框架提供的一系列API，可以做到

    1. 取消还没有展示的通知，直接调用删除方法
    2. 修改还没有展示的通知，用相同的标识符再发送一条通知，即可实现覆盖修改
    3. 删除已经展示过的通知，直接调用删除方法
    4. 修改已经展示过的通知，用相同的标识符再发送一条通知，即可实现覆盖修改

```
//创建两个用于测试的消息体  
UNMutableNotificationContent *content1 = [[UNMutableNotificationContent alloc]init];  
content1.title = @"1";  
content1.body = @"通知1";  

UNMutableNotificationContent *content2 = [[UNMutableNotificationContent alloc]init];  
content2.title = @"2";  
content2.body = @"通知2";
  
UNTimeIntervalNotificationTrigger *trigger = [UNTimeIntervalNotificationTrigger triggerWithTimeInterval:5 repeats:NO];  
NSString *identifier = @"SendAndCancle";  
UNNotificationRequest *request = [UNNotificationRequest requestWithIdentifier:identifier content:content1 trigger:trigger];  

[[UNUserNotificationCenter currentNotificationCenter] addNotificationRequest:request withCompletionHandler:^(NSError * _Nullable error) {  
    //  
}];  

//延迟2秒之后执行  
dispatch_time_t delayTime = dispatch_time(DISPATCH_TIME_NOW, (int64_t)(2.0/*延迟执行时间*/ * NSEC_PER_SEC));  

dispatch_after(delayTime, dispatch_get_main_queue(), ^{  
[[UNUserNotificationCenter currentNotificationCenter] 
    //取消还没有展示的通知
    removePendingNotificationRequestsWithIdentifiers:@[identifier]];  

    //用相同的标识再次发送即可覆盖  
    UNTimeIntervalNotificationTrigger *triggerNew = [UNTimeIntervalNotificationTrigger triggerWithTimeInterval:3 repeats:NO];  

    UNNotificationRequest *requestNew = [UNNotificationRequest requestWithIdentifier:@"SendAndModify" content:content2 trigger:triggerNew];  

    [[UNUserNotificationCenter currentNotificationCenter] addNotificationRequest:requestNew withCompletionHandler:^(NSError * _Nullable error) {  
        //  
    }];
});
```




